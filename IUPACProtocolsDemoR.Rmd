---
title: 'WorldFAIR Chemistry: Protocol Services'
author: "WorldFAIR Chemistry"
date: "2023-10-08"
output:
  pdf_document: default
  html_document: default
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r IUPAC graphic, out.width='25%', fig.align='center', echo=FALSE}
knitr::include_graphics('book/images/iupac_and_wf.jpg')
```

## Interactive Demonstration

This notebook is intended as an interactive demonstration of the services 
being proposed by the IUPAC WorldFAIR Chemistry D3.3 project team. 
A complete description of the project is available at
<https://iupac.github.io/WFChemProtocols/intro.html>.

This notebook is an RMarkdown version of the original Jupyter Notebook, 
which is available at
<https://github.com/IUPAC/WFChemProtocols/blob/main/IUPACProtocolsDemo.ipynb>.


## Resolver Summary

While more detail is provided in the documentation linked above, in short 
what is described here is a web service called a "resolver" that performs 
two main functions:

1. Check for the presence of a chemical record in the hosting organization's database.
2. Validate the machine-readable chemical structure according to the hosting organization's rules.


## Resolver Base URL

The service being proposed in this project is a regular HTTP web service, 
using standard CGI URL syntax, and a well-defined data model for the 
information returned. This demonstration uses a prototype service hosted 
by PubChem, using JSON as the response format (although in principle it 
could be XML or any other structured data format).

One key point of this proposal is that the base URL for the resolver CGI 
would vary from one institution to another, but the inputs (CGI arguments) 
and outputs (JSON data) would be standard, the same for any organization
implementing the service. So simply by switching the base URL, one can run 
the same query on multiple different sites, without otherwise needing to 
change any code.

In R, this could look like this:

```{r preparation}
library(httr2)
resolver_base_url <- "https://pubchem.ncbi.nlm.nih.gov/resolver/resolver.cgi"
```

When called without any arguments, the resolver will return some information 
about what inputs and outputs it can handle.

```{r example with no input}
req <- request(resolver_base_url)
res <- req |> req_perform()
```

```{r display results}
# display the input and results
req$url
# display raw data
res |> resp_body_string() |> cat()
# display as R object
res |> resp_body_json()
```

## Chemical Lookup

The resolver service can check to see whether a given chemical is present in 
the host organization's database. Examples are below, but note that in this
interactive document, one can edit the inputs to query whatever 
chemical is desired.

First, to look up by SMILES string:

```{r request SMILES query}
req <- req |> 
  req_url_query(smiles = "CCCC") 
# perform request
res <- req |> req_perform()
```

```{r display SMILES results}
# display URL
req$url
# display raw data
res |> resp_body_string() |> cat()
# display as R object
res |> resp_body_json()
```

In this example code, the URL is first constructed using `req_url_query` and 
then encoded and retrieved using the response functions from the `httr2` package.
The resulting data indicates that there is indeed a 
matching record in the host's database, and various record fields are provided 
that would allow the user to get more information directly from the hosting 
site; this is not intended for full record retrieval, but rather a simplified
response that says whether the chemical is found and where to go to get more
detail. So in this case the user can follow the link to the full PubChem record:

<https://pubchem.ncbi.nlm.nih.gov/compound/7843>

Or see an image of the chemical structure 
(although not terribly interesting in this case!):

<!-- If html, renders live -->
<!-- ![https://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?t=l&cid=7843](https://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?t=l&cid=7843) -->

<!-- If PDF, use pre-downloaded file -->
```{r butane img, out.width='25%', fig.align='center', echo=FALSE}
knitr::include_graphics('book/images/imgsrv_7843.png')
```
<https://pubchem.ncbi.nlm.nih.gov/image/imgsrv.fcgi?t=l&cid=7843>

If the chemical is not in the database, the response would be something like 
this, where an empty result means nothing was found (this could also potentially 
be indicated by an HTTP 404 response, but is not done that way in this sample
implementation):

```{r non-existing SMILES}
req <- request(resolver_base_url) |> 
  req_url_query(smiles = "CCCC(Br)CC(F)(Cl)CCC") 
# perform request
res <- req |> req_perform()
# display
req$url
# display raw data
res |> resp_body_string() |> cat()
```

The resolver can handle multiple input formats for the chemical structure, 
as listed in the previous section. So all of these would return the same 
result, which can be verified by (un)commenting various query lines below:

```{r multiformat lookup}
# # SMILES
# req <- request(resolver_base_url) |>
#   req_url_query(smiles = "CCCC")

# InChI
req <- request(resolver_base_url) |>
  req_url_query(inchi = "InChI=1S/C4H10/c1-3-4-2/h3-4H2,1-2H3")

# # InChIKey
# req <- request(resolver_base_url) |>
#   req_url_query(inchikey = "IJDNQMDRQITEOD-UHFFFAOYSA-N")

# # Name
# req <- request(resolver_base_url) |>
#   req_url_query(name = "butane")

## Request and display results
# perform request
res <- req |> req_perform()
# display
req$url
# display raw data
res |> resp_body_string() |> cat()

```

Note that the InChI full string needs to be URL-encoded in order to be passed 
as an argument to the CGI, as would some SMILES strings with special characters.
This is handled automatically with the `httr2` functions used in these examples.

## Chemical Structure Validation

TBC...


